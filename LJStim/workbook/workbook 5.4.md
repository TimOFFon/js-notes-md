## Оглавление
### Конспект
________________________
+ [Методы примитивов 5.1](obsidian://open?vault=StorageMDF&file=LJStim%2Fworkbook%2Fworkbook%205.1)
+ [Числа 5.2](obsidian://open?vault=StorageMDF&file=LJStim%2Fworkbook%2Fworkbook%205.2)
+ [Строки 5.3](obsidian://open?vault=StorageMDF&file=LJStim%2Fworkbook%2Fworkbook%205.3)
+ [Массивы 5.4](obsidian://open?vault=StorageMDF&file=LJStim%2Fworkbook%2Fworkbook%205.4)


### Заметки
+ [Числа 5.2](obsidian://open?vault=StorageMDF&file=LJStim%2Fnotes%2Fnote%205.2)
__________________________
## Массив
**`Array`** - особая структура данных  для хранения упорядоченных коллекций. 

Эффетивны для работы с упорядоченными данными.

Индексация с нуля. 

Длина - общее число элементов.

Хранит  элементы любого типа.

Следует помнить, что в JavaScript существует 8 основных типов данных. Массив является объектом и, следовательно, ведёт себя как объект, например, копируется по ссылке.

Массивы не имеют ни `Symbol.toPrimitive`, ни функционирующего `valueOf`, они реализуют только преобразование `toString`, таким образом, здесь `[]` становится пустой строкой, `[1]` становится `"1"`, а `[1,2]` становится `"1,2"`.

Может оканчиваться висячей запятой.

Могут быть многомерными (массив массивов).

### Метод **`at()`**
принимает значение в виде целого числа и возвращает элемент массива с данным индексом. В качестве аргумента метод принимает положительные и отрицательные числа. При отрицательном значении отсчёт происходит с конца массива.
Если переданный индекс не может быть найден, возвращает **`undefined`**.

### Методы **`pop/push, shift/unshift`**
**`.pop()`** - Удаляет последний элемент из массива и возвращает его.

**`.push()`** -  Добавляет элемент в конец массива.

**`.shift()`** - Удаляет из массива первый элемент и возвращает его.

**`.unshift()`** - Добавляет элемент в начало массива.

**`Очередь`** – один из самых распространённых вариантов применения массива. В области компьютерных наук так называется упорядоченная коллекция элементов, поддерживающая два вида операций:
-   **`push`** добавляет элемент в конец.
-   **`shift`** удаляет элемент в начале, сдвигая очередь, так что второй элемент становится первым.


**`Стек`** - структура данных, другой вариант применения для массивов, новые элементы всегда добавляются или удаляются из «конца».
-   **`push`** добавляет элемент в конец.
-   **`pop`** удаляет последний элемент.

### `toString`
Массивы по-своему реализуют метод `toString`, который возвращает список элементов, разделённых запятыми.

![[workbook 5.3.10.jpg]]
### Перебор элементов
По цифровым индексам - `for` 
По значению - `for..of` (он быстрее)
### Эффективность

![[workbook 5.3.11.jpg]]

**Почему работать с концом массива быстрее, чем с его началом?**

Просто взять и удалить элемент с номером `0` недостаточно. Нужно также заново пронумеровать остальные элементы.

Операция `shift` должна выполнить 3 действия:

1.  Удалить элемент с индексом `0`.
2.  Сдвинуть все элементы влево, заново пронумеровать их, заменив `1` на `0`, `2` на `1` и т.д.
3.  Обновить свойство `length` .

**Чем больше элементов содержит массив, тем больше времени потребуется для того, чтобы их переместить, больше операций с памятью.**

То же самое происходит с `unshift`: чтобы добавить элемент в начало массива, нам нужно сначала сдвинуть существующие элементы вправо, увеличивая их индексы.

А что же с `push/pop`? Им не нужно ничего перемещать. Чтобы удалить элемент в конце массива, метод `pop` очищает индекс и уменьшает значение `length`.

**Метод `pop` не требует перемещения, потому что остальные элементы остаются с теми же индексами. Именно поэтому он выполняется очень быстро.**