## Оглавление
### Конспект
________________________
+ [Методы примитивов 5.1](obsidian://open?vault=StorageMDF&file=LJStim%2Fworkbook%2Fworkbook%205.1)
+ [Числа 5.2](obsidian://open?vault=StorageMDF&file=LJStim%2Fworkbook%2Fworkbook%205.2)
+ [Строки 5.3](obsidian://open?vault=StorageMDF&file=LJStim%2Fworkbook%2Fworkbook%205.3)
+ [Массивы 5.4](obsidian://open?vault=StorageMDF&file=LJStim%2Fworkbook%2Fworkbook%205.4)


### Заметки
+ [Числа 5.2](obsidian://open?vault=StorageMDF&file=LJStim%2Fnotes%2Fnote%205.2)
__________________________
## Числа
### Дополнение

**Формат IEEE 754...      "Двойная точность"...        Что?!?**

Я искал дополнительный материал, который  популярным языком мог бы раскрыть эту тему.

Вот пару ссылок которые стоило бы посетить, чтобы проникнуться смыслом темы "двойной точности", и формата IEEE 754:

https://www.youtube.com/watch?v=ej3EA451m2c&list=PLawfWYMUziZqyUL5QDLVbe3j5BKWj42E5&index=5

https://habr.com/ru/post/331814/

### IEEE 754

Обычные - в 64-битном формате  [IEEE-754](http://en.wikipedia.org/wiki/IEEE_754-1985), уже 24 года широко используется для вычислений с плавающей запятой. 

IEEE 754 - представляет числа в двоичном виде, предоставляя определения для четырех уровней точности, в JS используется уровень "Двойная точность". (Примерно 16 десятичных цифр)

 51 бит под числа, 1 бит под знак, и 11 из них для хранения положения десятичной точки (если число целое, то хранится 0). Поэтому не удивляйтесь если обнаружите, что синтаксис языка принимает `-0` и `-infinity`, потому-что один бит зарезервирован под знак.

### Способы записи числа

![[workbook 5.2.1.jpg]]
В JS можно писать меньше нулей используя букву `е`.
![[workbook 5.2.2.jpg]]
Буква `е` производит умножение на еденицу с указанным количеством нулей.
![[workbook 5.2.3.jpg]]

Так же `е` можно использовать и в записи десятичных дробей.
![[workbook 5.2.4.jpg]]
![[workbook 5.2.5.jpg]]

Отрицательное число после `е` подразумевает деление на 1 с указанным количеством нулей.

Шестнадцатеричные число широко используются в JS для кодировки цветов, символов и много другого.

Короткий стиль записи: `0х`, после которого указывается число.

![[workbook 5.2.6.jpg]]

Для записи двоичных и восмеричных числе используются: `двоичные` -> `0b`, `восмеричные` -> `0o`.

![[workbook 5.2.7.jpg]]

Только 3 системы счисления с такой поддержкой

### toString(base)

возвращает строковое представление числа `num` в системе счисления `base`.

![[workbook 5.2.12.jpg]]

Если используем вместо `num` непосредственно число, то используем ДВЕ точки для вызова метода!!!  Первая точка может интропретироваться как обозначение дроби, вторая точка исключает это и вызывает метод.
рис.двеТочки1

### Округление

Это основные методы с которым нам придётся работать в JS при использовании чисел, из-за особенностей двоичного формата изчисления, в котором представлены числа на низком уровне вычислений. Единицу сложно разделить на 3 без остатка, и остаток постоянно копится, выдавая `удивительные результаты`. Но  сэтим можно свыкнуться освоив методы округления. Коих всего 4.


#### Math.floor 
- округляет в меньшую сторону.
- _________________________________________________

#### Math.ceil 
- округляет в большую сторону.
- _________________________________________________

#### Math.round  
- округляет до ближайшего целого.
- _________________________________________________

#### Math.trunc  
- отрезает по запятую.
- _________________________________________________

![[workbook 5.2.8.jpg]]

Если нам надо округлить число до `n-ого` количества цифр в дробной части, то у нас есть два способа: 
`умножить и разделить`  и `метод toFixed(n)`.

1). "умножить и разделить"  - например у нас есть  `1.2345` и мы хотим округлить число до 2-х знаков после запятой, оставить только `1.23`, мы можем умножить число на `100`, вызвать функцию округления и разделить обратно.
рис. управлОкругление1.

2). "метод toFixed(n)" - округляет число до `n` знаков после запятой и возвращает строковое представление результата.
Округляет значение до ближайшего числа, как в большую, так и в меньшую сторону, аналогично методу `Math.round`.
рис.тоФиксед2.


### Неточные вычисления

"Неточные вычисления" - это самая основная тема связанна с работой с числами, и главная тема этой заметки.  
В чём корень проблемы, почему это происходит?
Представьте себе десятичную дробь, например `0,1`, в десятичной системе исчесления это просто сделать, т.е. мы берём `1` и делим её на `10`, но представьте себе `1 / 3`, результат чего приводит к бесконечной дроби `0.33333`. Точно такой же феномен происходит в двоичной системе исчисления. Например в тот момент когда мы делим `1 / 10`. 
В JavaScript нет возможности для хранения точных значений `0.1` или `0.2`, используя двоичную систему, точно также, как нет возможности хранить одну третью в десятичной системе счисления.
Эта проблема решается в JS путём округления до ближайшего возможного числа.



### Проверка: isFinite и isNaN

Следует помнить, `NaN`  - это особое числовое згачение, которое не равно ни чему, даже самому себе, это создает особенность, требующую особого подхода при сравнении.
Для этого создан специальный метод `isNaN()`, но он не рекоммендован к использованию, т.к преобразование происходит с оглядкой на IEEE-794, путсая строка и булево значение, которое при обычном числовом приоброзавании были бы приведены к нулю, в этом случае приводят к "not a number". Поэтому лучше использовать `Number.isNaN()`, этот метод не имеет проблем с принудительным числовым преобразованием и возвращает `true` только для числовых значений, имеющих значение `NaN`, а также метод `Object.is()`, он определяет, являются ли два значения одинаковыми значениями, он корректен по отношению всех уникальных числовых значений.
Тоже касается и `isFinite`,  лучше использовать `Number.isFinite(testValue)`
В отличии от глобальной функции `isFinite()`, этот метод принудительно не преобразует параметр в число. Это означает, что он возвращает `true` только для конечных значений числового типа.

![[workbook 5.2.13.jpg]]

`infinit` - математическая бесконечноть,
`NaN` - ошибка
Эти числовые значения типа `number` не являются обычными числами, и есть специальные функции для их проверки. 

`isNaN(value)` преобразует значение в число и проверяет является ли оно `NaN`.

`isFinite(value)` преобразует аргумент в число и возвращает `true`, если оно является обычным числом, т.е. не `NaN/Infinity/-Infinity`.

Иногда `isFinite` используется для проверки, содержится ли в строке число.

Помните, что пустая строка интерпретируется как `0` во всех числовых функциях, включая`isFinite`.


### Сравнение Object.is

Существует специальный метод `Object.is`, который сравнивает значения примерно как `===`, но более надёжен в двух особых ситуациях:

1.  Работает с `NaN`: `Object.is(NaN, NaN) === true`, здесь он хорош.

2.  Значения `0` и `-0` разные: `Object.is(0, -0) === false`, это редко используется, но технически эти значения разные.

Во всех других случаях `Object.is(a, b)` идентичен `a === b`.


### parseInt и parseFloat

Они «читают» число из строки. Если в процессе чтения возникает ошибка, они возвращают полученное до ошибки число. 

Функция `parseInt` возвращает целое число.

Функция `parseFloat` возвращает число с плавающей точкой.

Функции `parseInt/parseFloat` вернут `NaN`, если не смогли прочитать ни одну цифру:

`alert( parseInt('a123') );`  // `NaN`, на первом символе происходит остановка чтения



#### Второй аргумент `parseInt(str, radix)`

Функция `parseInt()` имеет необязательный второй параметр. Он определяет систему счисления, таким образом `parseInt` может также читать строки с шестнадцатеричными числами, двоичными числами и т.д.:



### Другие математические методы
Всего их около четырёх десятков, часть из них возможно никогда нам не потребуется, поэтому следует упомянуть о наиболее вероятно полезных из них.

`Math.random()`  -  Возвращает псевдослучайное число в диапазоне от 0 (включительно) до 1 (но не включая 1);

`Math.max(a, b, c...)` / `Math.min(a, b, c...)` - 
Возвращает наибольшее/наименьшее число из перечисленных аргументов;

`Math.pow(n, power)` - Возвращает число `n`, возведённое в степень `power`;

`Math.cbrt(x)` -  Возвращает кубический корень числа;

`Math.sqrt(x)` - Возвращает положительный квадратный корень числа;

Как и большинство встроенных объектов в Javascript, объект `Math` может быть расширен пользовательскими способами и методами. Чтобы расширить объект `Math`, не используют `prototype`. Вместо этого, расширяют `Math` напрямую.